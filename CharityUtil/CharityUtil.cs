using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Schema;
using Newtonsoft.Json.Schema.Generation;
using System.Security.Cryptography;
using System.Text;

public static class CharityUtil
{
    public static string CreatePasswordHash(string password, string salt)
    {
        byte[] passwordBytes = Encoding.UTF8.GetBytes(password);
        byte[] saltBytes = Encoding.UTF8.GetBytes(salt);
        using var hmac = new HMACSHA512(saltBytes);
        var hashBytes = hmac.ComputeHash(passwordBytes);
        return Convert.ToBase64String(hashBytes);
    }

    public static string GenerateSalt(int length = 32)
    {
        // Create a new instance of the RNGCryptoServiceProvider
        RandomNumberGenerator rng = RandomNumberGenerator.Create();

        // Create a byte array to store the salt value
        byte[] saltBytes = new byte[length];

        // Fill the byte array with random values generated by the RNGCryptoServiceProvider
        rng.GetBytes(saltBytes);

        // Convert the byte array to a string and return it
        return Convert.ToBase64String(saltBytes);
    }

    public static bool VerifyPasswordHash(string password, string hashPassword, string saltPassword)
    {
        var saltPasswordBytes = Encoding.UTF8.GetBytes(saltPassword);
        var hashPasswordBytes = Convert.FromBase64String(hashPassword);
        using (var hmac = new System.Security.Cryptography.HMACSHA512(saltPasswordBytes))
        {
            var computedHashBytes = hmac.ComputeHash(Encoding.UTF8.GetBytes(password));
            if (computedHashBytes == null || hashPasswordBytes == null || computedHashBytes.Length != hashPasswordBytes.Length)
            {
                return false;
            }
            for (int i = 0; i < computedHashBytes.Length; i++)
            {
                if (computedHashBytes[i] != hashPasswordBytes[i])
                {
                    return false;
                }
            }
            return true;
        }
    }

    public static bool CanBeConverted<T>(object value) where T : class
    {
        var jsonData = JsonConvert.SerializeObject(value);
        var generator = new JSchemaGenerator();
        var parsedSchema = generator.Generate(typeof(T));
        var jObject = JObject.Parse(jsonData);
        return jObject.IsValid(parsedSchema);
    }

    public static T ConvertToType<T>(object value) where T : class
    {
        var jsonData = JsonConvert.SerializeObject(value);
        return JsonConvert.DeserializeObject<T>(jsonData);
    }
}
