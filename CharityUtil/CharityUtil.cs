using MailKit.Net.Smtp;
using MailKit.Security;
using MimeKit;
using MimeKit.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Schema;
using Newtonsoft.Json.Schema.Generation;
using System.Dynamic;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Security.Authentication;
using System.Security.Cryptography;
using System.Text;
public static class CharityUtil
{
    public static string CreatePasswordHash(string password, string salt)
    {
        byte[] passwordBytes = Encoding.UTF8.GetBytes(password);
        byte[] saltBytes = Encoding.UTF8.GetBytes(salt);
        using var hmac = new HMACSHA512(saltBytes);
        var hashBytes = hmac.ComputeHash(passwordBytes);
        return Convert.ToBase64String(hashBytes);
    }

    public static string GenerateSalt(int length = 32)
    {
        // Create a new instance of the RNGCryptoServiceProvider
        RandomNumberGenerator rng = RandomNumberGenerator.Create();

        // Create a byte array to store the salt value
        byte[] saltBytes = new byte[length];

        // Fill the byte array with random values generated by the RNGCryptoServiceProvider
        rng.GetBytes(saltBytes);

        // Convert the byte array to a string and return it
        return Convert.ToBase64String(saltBytes);
    }

    public static bool VerifyPasswordHash(string password, string hashPassword, string saltPassword)
    {
        var saltPasswordBytes = Encoding.UTF8.GetBytes(saltPassword);
        var hashPasswordBytes = Convert.FromBase64String(hashPassword);
        using (var hmac = new System.Security.Cryptography.HMACSHA512(saltPasswordBytes))
        {
            var computedHashBytes = hmac.ComputeHash(Encoding.UTF8.GetBytes(password));
            if (computedHashBytes == null || hashPasswordBytes == null || computedHashBytes.Length != hashPasswordBytes.Length)
            {
                return false;
            }
            for (int i = 0; i < computedHashBytes.Length; i++)
            {
                if (computedHashBytes[i] != hashPasswordBytes[i])
                {
                    return false;
                }
            }
            return true;
        }
    }

    public static void SendMailKit(string to, string subject, string html)
    {
        // create message
        var email = new MimeMessage();
        email.From.Add(MailboxAddress.Parse("hoailinh.ahihi@gmail.com"));
        email.To.Add(MailboxAddress.Parse(to));
        email.Subject = subject;
        email.Body = new TextPart(TextFormat.Html) { Text = html };

        // send email
        using var smtp = new SmtpClient();
        smtp.CheckCertificateRevocation = false;
        //smtp.SslProtocols = SslProtocols.Ssl3 | SslProtocols.Tls | SslProtocols.Tls11 | SslProtocols.Tls12 | SslProtocols.Tls13;
        smtp.Connect("smtp.gmail.com", 587, SecureSocketOptions.StartTls);

        // Note: since we don't have an OAuth2 token, disable
        // the XOAUTH2 authentication mechanism.
        smtp.AuthenticationMechanisms.Remove("XOAUTH2");
        smtp.Authenticate("hoailinh.ahihi@gmail.com", "jhuubqzghnabiyss");
        smtp.Send(email);
        smtp.Disconnect(true);
    }

    public static ExpandoObject ToExpando(object model)
    {
        if (model is ExpandoObject exp)
        {
            return exp;
        }

        IDictionary<string, object> expando = new ExpandoObject();
        foreach (var propertyDescriptor in model.GetType().GetTypeInfo().GetProperties())
        {
            var obj = propertyDescriptor.GetValue(model);

            if (obj != null && IsAnonymousType(obj.GetType()))
            {
                obj = ToExpando(obj);
            }

            expando.Add(propertyDescriptor.Name, obj);
        }

        return (ExpandoObject)expando;
    }

    private static bool IsAnonymousType(Type type)
    {
        bool hasCompilerGeneratedAttribute = type.GetTypeInfo()
            .GetCustomAttributes(typeof(CompilerGeneratedAttribute), false)
            .Any();

        bool nameContainsAnonymousType = type.FullName.Contains("AnonymousType");
        bool isAnonymousType = hasCompilerGeneratedAttribute && nameContainsAnonymousType;

        return isAnonymousType;
    }

    public static bool CanBeConverted<T>(object value) where T : class
    {
        var jsonData = JsonConvert.SerializeObject(value);
        var generator = new JSchemaGenerator();
        var parsedSchema = generator.Generate(typeof(T));
        var jObject = JObject.Parse(jsonData);
        return jObject.IsValid(parsedSchema);
    }

    public static T ConvertToType<T>(object value) where T : class
    {
        var jsonData = JsonConvert.SerializeObject(value);
        if (jsonData.Contains("\"Id\":null,"))
        {
            jsonData = jsonData.Replace("\"Id\":null,", String.Empty);
        }
        return JsonConvert.DeserializeObject<T>(jsonData);
    }
}
